--- Main ---

The malware sample belongs to a technical challenge. Manual offline analysis performed, as per request. This does not represent a "product" or "blog post." Instead, I focused on demonstrating my RE approach.

Original file name and MD5: F6C022C12DE775DD1A9BFBD9F44498DF
SHA1: 05C33AD6CAC836C74816A2801B822BBBFA52D9D6
File size: 9 KB

Test machine: Windows 10 Pro 64-bit (10.0, Build 17134), 8192MB RAM, English
Virtualization: VMWare Workstation 15 Pro 15.0.4 build-12990004

Comments: In this assessment, this is the second (2) sample I worked with.


--- Static Analysis ---

I have given the sample the file name mw1.

A quick look via hex editor indicates mw1 is an RTF (Rich Text Format) file. Beyond the RTF header, a potential payload exists as an RTF object in ASCII hexadecimal. 

We can use RTFScan to dump the OLE content within:

	C:\WINDOWS\system32>RTFScan c:\users\admin\desktop\mw1 scan

	+------------------------------------------+
	|              RTFScan v0.26               |
	|  Frank Boldewin / www.reconstructer.org  |
	+------------------------------------------+

	[*] SCAN mode selected
	[*] Opening file c:\users\admin\desktop\mw1
	[*] Filesize is 8336 (0x2090) Bytes
	[*] RTF format detect

	Embedded OLE document found in OBJDATA

	Scanning for shellcode in OBJDATA...
	JMP [0xEB]/CALL/POP signature found at offset: 0xadc

	Dumping embedded OLE document as filename: OLE_DOCUMENT__mw1__1.bin


	        !!! OLE_DOCUMENT has been found and dumped. This should be re-scanned with officemalscanner now !!!


	Analysis finished!

	-----------------------------------------------
	mw1 seems to be malicious! Malicious Index = 10
	-----------------------------------------------


Next, a scan for Visual Basic code:

	C:\WINDOWS\system32>officemalscanner c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin info

	+------------------------------------------+
	|           OfficeMalScanner v0.62         |
	|  Frank Boldewin / www.reconstructer.org  |
	+------------------------------------------+

	[*] INFO mode selected
	[*] Opening file c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin
	[*] Filesize is 4104 (0x1008) Bytes
	[*] Ms Office OLE2 Compound Format document detected

	--------------------------------------------------
	[Scanning for VB-code in OLE_DOCUMENT__MW1__1.BIN]
	--------------------------------------------------
	-----------------------
	No VB-Macro code found!


Next, another scan. This one has interesting results:

	C:\WINDOWS\system32>officemalscanner c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin scan brute debug

	+------------------------------------------+
	|           OfficeMalScanner v0.62         |
	|  Frank Boldewin / www.reconstructer.org  |
	+------------------------------------------+

	[*] SCAN mode selected
	[*] Opening file c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin
	[*] Filesize is 4104 (0x1008) Bytes
	[*] Ms Office OLE2 Compound Format document detected
	[*] Scanning now...

	JMP [0xEB]/CALL/POP signature found at offset: 0xadc

	EB1E                               jmp $+20h
	EB09                               jmp $+0Bh
	E98E000000                         jmp $+00000093h
	EBA5                               jmp $-59h
	51                                 push ecx
	59                                 pop ecx
	EB4A                               jmp $+4Ch
	EB02                               jmp $+04h
	07                                 pop es
	7BEB                               jnp $-13h
	855053                             test edx, [eax+53h]
	5B                                 pop ebx
	52                                 push edx
	53                                 push ebx
	5B                                 pop ebx
	E973FFFFFF                         jmp $-00000088h
	--------------------------------------------------------------------------


	Brute-forcing for encrypted PE- and embedded OLE-files now...
	Bruting XOR Key: 0xff
	Bruting ADD Key: 0xff
	Bruting ROL Key: 0x08


	Analysis finished!


Note the found +0xadc offset. This will serve as an entry point for live debugging.

Next, using MalHost-Setup, we can produce a debuggable host executable for the malware shellcode:

	C:\WINDOWS\system32>malhost-setup c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin mw2 0xadc wait

	+------------------------------------------+
	|            MalHost-Setup v0.15           |
	|  Frank Boldewin / www.reconstructer.org  |
	+------------------------------------------+

	[*] WAIT option chosen
	[*] Opening file c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin
	[*] Filesize is 4104 (0x1008) Bytes
	[*] Original bytes [0xeb 0x1e] at offset 0xadc
	[*] Original bytes are patched for debugging now [0xeb 0xfe]
	[*] Creating Malhost file now...
	[*] Writing 57352 bytes


--- Live Analysis ---

We have generated a new mw2(.exe) for debugging. We can open mw2.exe in the x32dbg debugger and observe the shellcode running. Pausing the debugger will reveal the "JMP to EIP" loop applied by MalHost-Setup. To resume execution, we can patch the original bytes at EIP: 0xeb 0x1e as noted by MalHost-Setup. But before we do that, we can use x32dbg's Graph view to better understand execution flow. Looking over the code, there are many useless or obfuscated instructions: jumps all over the place, useless pushed and popped instructions, etc. Within the obfuscation, there appears to be a payload decryption routine. Also, XOR DWORD PTR SS:[EBP], EDX at file offset +0xb41 may well provide decrypted output. That instruction is breakpoint worthy.

Drats! mw2.exe soon crashes whilst debugging due to junk code.

Something appears to be wrong. Two possibilities come to mind:

	a) MalHost-Setup was unhelpful.
	b) This assessment is a Kobayashi Maru exercise; i.e. the shellcode is intended to crash and the focus is documenting solution attempts.


--- Static Analysis ---

We must consider whether +0xadc was the wrong shellcode entry point given to us by MalHost-Setup. Let's take a different approach that does not rely on automated tools. We can skim through the assembly for the first intelligible instruction. Scrolling back in x32dbg, the first such instruction, a JMP, appears at +0xa5a.

Let's use MalHost again using the potentially valid +0xa5a shellcode entry point:

	C:\WINDOWS\system32>malhost-setup c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin mw2 0xa5a wait

	+------------------------------------------+
	|            MalHost-Setup v0.15           |
	|  Frank Boldewin / www.reconstructer.org  |
	+------------------------------------------+

	[*] WAIT option chosen
	[*] Opening file c:\users\admin\desktop\OLE_DOCUMENT__mw1__1.bin
	[*] Filesize is 4104 (0x1008) Bytes
	[*] Original bytes [0xe9 0x92] at offset 0xa5a
	[*] Original bytes are patched for debugging now [0xeb 0xfe]
	[*] Creating Malhost file now...
	[*] Writing 57352 bytes


--- Live Analysis ---

We can now try debugging the new mw2(.exe) in x32dbg to see if the new +0xa5a entry point is valid. 

Yes, a good sign: we can trace further. Another sign of success: tracing through the code and using the +0xb41 decoded output breakpoint mentioned earlier, we can see the beginning of intelligible output. A Unicode string starting with "http" is built. We know we are on the right track. To save time, we can look for a conditional instruction that determines if the decoding routine is complete. Indeed, +0xa66 will execute upon decryption routine completion. Breakpoint applied and triggered. The decrypted data in the output buffer is approximately 880 bytes. We can now focus on x32dbg's disassembler view on the new payload.

By the way, we could have emulated the decryption routine with help from Snowman's C/C++ decompiler or removed junk instructions manually to generate a shellcode decrypter for Multiline Ultimate Assembler or an external shellcode tool. However, this would have consumed time unnecessarily.

Let's call this new payload mw3.

	Interesting Unicode strings in mw3:

		http://b.reich.io/hnepyp.scr
		%APPDATA%\name.exe


	Interesting ASCII strings in mw3:

		LoadLibraryA
		GetProcAddress
		Urlmon
		ExitProcess
		URLDownloadToFileW
		ExpandEnvironmentStringsW
		CreateProcessW
		GetStartupInfoW


The above Windows APIs and other strings suggest the downloading and execution of a malicious executable.

Note that the decrypted code excludes a PE header. This suggests the new payload will execute in memory as-is, which is more evasive than writing the dropper to disk.

I went ahead and tried downloading http://b.reich.io/hnepyp.scr outside of x32dbg. The download failed. The web hosting provider likely took action, as malware usually violates web hosting terms of service.

Continued tracing shows the new payload will be executed by the current payload at +0xafc. 

Next, we will keep tracing to see whether the sample will execute the decoded instructions in memory or drops a downloader. As a precaution, I glanced over the 880 bytes of the decoded malware dropper and set a total of four breakpoints on PUSH EBP instructions. This is helpful in case I step over an instruction that ends up invoking the new payload.

Rather quickly, we can see the CALL at offset +0xbd5 executes the new payload in memory.

In order, the payload/dropper does the following:

	1. Parse the strings above and further establish the import table.
	(Note: XOR AX, 20 (de)capitalization trick is used.)
	2. Look up offset of LoadLibraryA via system library export string comparison.
	3. Look up offset of GetProcAddress via system library export string comparison.
	4. Call GetProcAddress for ExpandEnvironmentStringsW.
	5. Call ExpandEnvironmentStringsW for "%APPDATA%\name.exe".
	6. Call LoadLibraryA for Urlmon.
	7. Call GetProcAddress for Urlmon's URLDownloadToFileW.
	8. Call URLDownloadToFileW for http://b.reich.io/hnepyp.scr.
	(This fails because http://b.reich.io/hnepyp.scr is no longer available.)
	9. Call GetProcAddress for GetStartupInfoW.
	10. Call GetStartupInfoW (see returned STARTUPINFOA structure at https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa).
	11. Call GetProcAddress for CreateProcessW.
	12. Call CreateProcessW. The associated Unicode process path on my test machine is C:\Users\admin\AppData\Roaming\name.exe.
	(This would normally run name.exe, though name.exe does not exist due to the failed download.)
	13. Call GetProcAddress for ExitProcess.
	14. Call ExitProcess.
	(This terminates the MalHost-Setup host process containing mw2 and mw3.)

At this point, name.exe (hnepyp.scr) would have executed.


--- Conclusion ---

This malware is an unconventional RTF file that contains two x86 assembly payloads. Above, I refer to them as mw2 and mw3. mw2 decrypts and executes mw3 in memory. mw3 then attempts to download http://b.reich.io/hnepyp.scr and executes the download as name.exe. After this, the jobs of mw2 and mw3 are done. In total, this malware used three main levels of obfuscation; each with evasive qualities. While the most dangerous portion may be name.exe, the related hnepyp.scr is inaccessible.

Note to reviewer: if you want me to try tracking down a copy of hnepyp.scr, let me know the MD5 or SHA1. Alternatively, if you have a copy, I can take a look. Thanks!
